<!DOCTYPE html>
<!-- (c) 2019 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/master/LICENSE -->
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI Automatic Choreography</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
      canvas { display: block; }
      #loading {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: rgba(255,255,255,0.6); font-size: 13px; z-index: 200;
      }
    </style>
  </head>

  <body>
    <div id="loading">LOADING...</div>
    <canvas id="canvas2d" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:50;"></canvas>

    <script src="https://unpkg.com/three@0.108.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.108.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="./three-vrm.min.js"></script>

    <script>
// ============================================================
// UTILITIES
// ============================================================
const PHI = 1.618033988749895;
function organic(t, seed) {
  const s = seed * 137.508;
  return Math.sin(t+s)*0.4 + Math.sin(t*PHI+s*1.3)*0.3 + Math.sin(t*PHI*PHI+s*0.7)*0.2 + Math.sin(t*Math.PI+s*2.1)*0.1;
}
function smoothstep(a, b, t) { t = Math.max(0, Math.min(1, (t-a)/(b-a))); return t*t*(3-2*t); }
function lerp(a, b, t) { return a + (b-a) * t; }
function evalP(v, p) { return typeof v === 'function' ? v(p) : v; }

// ============================================================
// AUDIO SYSTEM
// ============================================================
class AudioSystem {
  constructor() {
    this.bass = 0; this.lowMid = 0; this.highMid = 0; this.treble = 0; this.overall = 0;
    this.beatDetected = false; this.lastBeatTime = -1;
  }
  update(time) {
    const b = Math.sin(time*2.2)*Math.sin(time*0.37);
    this.bass = 0.45 + 0.4*b;
    this.lowMid = 0.35 + 0.3*Math.sin(time*3.3+1);
    this.highMid = 0.25 + 0.25*Math.sin(time*5.7+2);
    this.treble = 0.2 + 0.18*Math.sin(time*8.1+3);
    this.overall = (this.bass+this.lowMid+this.highMid+this.treble)/4;
    this.beatDetected = false;
    const bp = (time*2.2) % 1;
    if (bp < 0.06 && time - this.lastBeatTime > 0.35) { this.beatDetected = true; this.lastBeatTime = time; }
  }
}

// ============================================================
// CAMERA SYSTEM - MV SHOTS
// ============================================================
class CameraSystem {
  constructor(camera) {
    this.camera = camera;
    this.autoSwitch = true;
    this.currentShot = 0;
    this.shotTime = 0;
    this.prevState = { pos:[0,1.2,4], tgt:[0,1,0], roll:0, fov:30 };
    this.transTime = 0;
    this.transDur = 0;
    this.shotName = '';
    this.focusDancer = 0;
    this.wideShots = new Set([6, 8, 9, 12]); // ORBIT, WIDE, PULL BACK, SPIN RISE

    // MV #1: Editing rhythm (largo/andante/allegro/presto)
    this.editingMode = 'andante';
    this.editingModeTimer = 0;
    this.editingModeDur = 25 + Math.random() * 20;
    // MV #2: Camera role (observer=dynamic / presenter=deliberate)
    this.cameraRole = 'observer';
    this.cameraRoleTimer = 0;
    this.cameraRoleDur = 22 + Math.random() * 15;
    // MV #4: Shot sequencing (establish→medium→close→breathe)
    this.shotPhase = 'establish';
    this.shotPhaseCount = 0;
    this.shotPhaseMax = 4;
    this.shotCategories = {
      establish: [6, 8, 9, 12],
      medium:    [0, 1, 9, 17, 13],
      close:     [2, 3, 4, 7, 10, 15, 16],
      breathe:   [5, 11, 14],
    };
    // MV #5: Choreography focus mode (locked wide, largo)
    this.choreoFocusMode = false;
    this.choreoFocusTimer = 0;
    this.choreoFocusDur = 0;
    this.worldCycleCount = 0;

    this.shots = [
      // 0: Front push-in
      { name:'PUSH IN', pos:p=>[0,1.2,lerp(5,2.5,p)], tgt:p=>[0,lerp(1,1.1,p),0], roll:0, fov:30, dur:4, cut:false, w:3 },
      // 1: Side tracking L→R
      { name:'SIDE TRACK', pos:p=>[lerp(-3,3,p),1.1,3], tgt:p=>[0,1,0], roll:0, fov:30, dur:4, cut:false, w:2 },
      // 2: Low hero
      { name:'HERO LOW', pos:p=>[lerp(0.3,-0.3,p),0.25,2.5], tgt:p=>[0,lerp(0.9,1.3,p),0], roll:0, fov:38, dur:3, cut:true, w:2 },
      // 3: Dutch angle left
      { name:'DUTCH L', pos:p=>[2,1,3], tgt:p=>[0,1,0], roll:0.18, fov:30, dur:3, cut:true, w:2 },
      // 4: Dutch angle right
      { name:'DUTCH R', pos:p=>[-2,0.8,2.5], tgt:p=>[0,1.1,0], roll:-0.2, fov:32, dur:3, cut:true, w:2 },
      // 5: Top-down
      { name:'TOP DOWN', pos:p=>[Math.sin(p*0.8)*0.8,lerp(4.5,3.8,p),lerp(0.3,0.8,p)], tgt:p=>[0,0.5,0], roll:p=>p*0.15, fov:40, dur:3, cut:true, w:1 },
      // 6: Orbit full
      { name:'ORBIT', pos:p=>[Math.sin(p*Math.PI*2)*3.5,1.2+Math.sin(p*Math.PI)*0.4,Math.cos(p*Math.PI*2)*3.5], tgt:p=>[0,1,0], roll:0, fov:30, dur:7, cut:false, w:3 },
      // 7: Extreme close-up face
      { name:'CLOSE UP', pos:p=>[lerp(0.15,-0.15,p),lerp(1.55,1.5,p),lerp(1.6,1.3,p)], tgt:p=>[0,1.48,0], roll:p=>Math.sin(p*Math.PI*2)*0.05, fov:22, dur:2.5, cut:true, w:2 },
      // 8: Wide
      { name:'WIDE', pos:p=>[0,lerp(1.5,2,p),lerp(8,7,p)], tgt:p=>[0,0.8,0], roll:0, fov:35, dur:4, cut:false, w:1 },
      // 9: Pull back reveal
      { name:'PULL BACK', pos:p=>[0,lerp(1.3,1.8,p),lerp(1.8,6,p)], tgt:p=>[0,1,0], roll:0, fov:p=>lerp(35,28,p), dur:5, cut:false, w:2 },
      // 10: Under chin
      { name:'UNDER', pos:p=>[lerp(-0.3,0.3,p),0.4,1.3], tgt:p=>[0,1.6,0], roll:0, fov:42, dur:2.5, cut:true, w:2 },
      // 11: Behind over-shoulder
      { name:'BEHIND', pos:p=>[lerp(0.6,-0.6,p),1.35,-1.8], tgt:p=>[0,1.1,2], roll:0.08, fov:35, dur:3, cut:true, w:1 },
      // 12: Spinning rise
      { name:'SPIN RISE', pos:p=>[Math.sin(p*Math.PI*3)*lerp(2,3.5,p),lerp(0.3,3.5,p),Math.cos(p*Math.PI*3)*lerp(2,3.5,p)], tgt:p=>[0,lerp(0.8,0.5,p),0], roll:p=>p*0.25, fov:30, dur:5, cut:false, w:2 },
      // 13: Fast half orbit
      { name:'FAST ORBIT', pos:p=>[Math.sin(p*Math.PI)*3.5,1,Math.cos(p*Math.PI)*3.5], tgt:p=>[0,1,0], roll:0, fov:30, dur:2, cut:true, w:2 },
      // 14: Feet focus
      { name:'FEET', pos:p=>[lerp(1.5,-1.5,p),0.2,2], tgt:p=>[0,0.25,0], roll:p=>Math.sin(p*Math.PI)*0.1, fov:30, dur:2.5, cut:true, w:1 },
      // 15: Dramatic low side
      { name:'DRAMA', pos:p=>[lerp(3,2.5,p),0.3,lerp(1,2,p)], tgt:p=>[0,1,0], roll:-0.12, fov:35, dur:3, cut:true, w:2 },
      // 16: Snap zoom
      { name:'SNAP ZOOM', pos:p=>[0,1.2,3], tgt:p=>[0,1.1,0], roll:0, fov:p=>lerp(60,20,smoothstep(0,0.3,p)), dur:2, cut:true, w:1 },
      // 17: Crane down
      { name:'CRANE', pos:p=>[1,lerp(4,0.8,p),lerp(4,2.5,p)], tgt:p=>[0,lerp(0.5,1,p),0], roll:p=>lerp(0.1,0,p), fov:30, dur:4, cut:false, w:2 },
    ];
  }

  getShotState(shot, p) {
    const pos = evalP(shot.pos, p);
    const tgt = evalP(shot.tgt, p);
    return { pos, tgt, roll: evalP(shot.roll, p), fov: evalP(shot.fov, p) };
  }

  switchShot() {
    const cur = this.shots[this.currentShot];
    const p = Math.min(1, this.shotTime / cur.dur);
    this.prevState = this.getShotState(cur, p);

    // MV #4: Phase advancement (establish→medium→close→breathe cycle)
    this.shotPhaseCount++;
    if (this.shotPhaseCount >= this.shotPhaseMax) {
      this.shotPhaseCount = 0;
      this.shotPhaseMax = 3 + Math.floor(Math.random() * 3);
      const seq = { establish:'medium', medium:'close', close:'breathe', breathe:'establish' };
      this.shotPhase = seq[this.shotPhase] || 'medium';
    }

    // Phase-aware candidate selection
    let candidates;
    if (this.choreoFocusMode) {
      // MV #5: Choreo focus → wide/orbit shots only
      candidates = [6, 8, 9].filter(i => i !== this.currentShot);
    } else {
      const phaseShots = this.shotCategories[this.shotPhase] || [];
      if (Math.random() < 0.72 && phaseShots.length > 0) {
        candidates = phaseShots.filter(i => i !== this.currentShot);
        if (candidates.length === 0) candidates = phaseShots;
      } else {
        candidates = this.shots.map((_,i) => i).filter(i => i !== this.currentShot);
      }
    }

    // Weighted pick from candidates
    const ws = candidates.map(i => this.shots[i].w);
    const total = ws.reduce((a,b) => a+b, 0);
    let r = Math.random() * total;
    let picked = candidates[candidates.length - 1];
    for (let k = 0; k < candidates.length; k++) { r -= ws[k]; if (r <= 0) { picked = candidates[k]; break; } }
    this.currentShot = picked;

    const next = this.shots[this.currentShot];
    this.shotTime = 0;
    this.transTime = 0;
    this.transDur = next.cut ? 0 : (0.6 + Math.random() * 0.8);
    this.shotName = next.name;
    this.focusDancer = Math.random() > 0.5 ? 0 : 1;
  }

  // MV #5: Called on each world switch
  onWorldSwitch() {
    this.worldCycleCount++;
    this.shotPhase = 'establish';
    this.shotPhaseCount = 0;
    if (!this.choreoFocusMode && this.worldCycleCount % 3 === 0) {
      // Every 3rd world: enter choreography focus mode (long wide shot)
      this.choreoFocusMode = true;
      this.choreoFocusDur = 15 + Math.random() * 8;
      this.choreoFocusTimer = 0;
      this.editingMode = 'largo';
    } else if (!this.choreoFocusMode) {
      // Random editing mode on world switch
      const modes = ['largo', 'andante', 'andante', 'allegro', 'presto'];
      this.editingMode = modes[Math.floor(Math.random() * modes.length)];
      this.editingModeTimer = 0;
      this.editingModeDur = 20 + Math.random() * 20;
    }
  }

  applyCamera(pos, tgt, roll, fov) {
    this.camera.position.set(pos[0], pos[1], pos[2]);
    this.camera.up.set(Math.sin(roll), Math.cos(roll), 0);
    this.camera.lookAt(tgt[0], tgt[1], tgt[2]);
    this.camera.fov = fov;
    this.camera.updateProjectionMatrix();
  }

  update(time, dt, audio, dancers) {
    if (!this.autoSwitch) return;

    // MV #1: Editing mode timer
    this.editingModeTimer += dt;
    if (this.editingModeTimer > this.editingModeDur && !this.choreoFocusMode) {
      this.editingModeTimer = 0;
      this.editingModeDur = 22 + Math.random() * 20;
      const modes = ['largo', 'andante', 'andante', 'allegro', 'presto'];
      this.editingMode = modes[Math.floor(Math.random() * modes.length)];
    }
    // MV #2: Camera role timer
    this.cameraRoleTimer += dt;
    if (this.cameraRoleTimer > this.cameraRoleDur) {
      this.cameraRoleTimer = 0;
      this.cameraRoleDur = 22 + Math.random() * 15;
      this.cameraRole = this.cameraRole === 'observer' ? 'presenter' : 'observer';
    }
    // MV #5: Choreo focus exit
    if (this.choreoFocusMode) {
      this.choreoFocusTimer += dt;
      if (this.choreoFocusTimer >= this.choreoFocusDur) {
        this.choreoFocusMode = false;
        this.editingMode = 'andante';
      }
    }

    // Wide shots frame both dancers; close shots focus one
    let fx, fz;
    if (this.wideShots.has(this.currentShot) && dancers.length > 1) {
      fx = (dancers[0].stageX + dancers[1].stageX) * 0.5;
      fz = (dancers[0].stageZ + dancers[1].stageZ) * 0.5;
    } else {
      const d = dancers[this.focusDancer % dancers.length] || dancers[0];
      fx = d.stageX || 0; fz = d.stageZ || 0;
    }

    this.shotTime += dt;
    const shot = this.shots[this.currentShot];

    // MV #1: Editing mode controls cut rate
    const durMult = { largo: 2.2, andante: 1.0, allegro: 0.55, presto: 0.28 }[this.editingMode] ?? 1.0;
    const beatSwitchThresh = { largo: 1.1, andante: 0.55, allegro: 0.35, presto: 0.15 }[this.editingMode] ?? 0.55;
    if (this.shotTime >= shot.dur * durMult) {
      this.switchShot();
    } else if (audio.beatDetected && this.shotTime > 1.0 && !this.choreoFocusMode && Math.random() > beatSwitchThresh) {
      this.switchShot();
    }

    // Target state from current shot
    const target = this.getShotState(this.shots[this.currentShot], Math.min(1, this.shotTime / this.shots[this.currentShot].dur));

    let pos, tgt, roll, fov;
    // Blend during transition
    if (this.transTime < this.transDur && this.transDur > 0) {
      this.transTime += dt;
      const t = smoothstep(0, 1, this.transTime / this.transDur);
      pos = [lerp(this.prevState.pos[0],target.pos[0],t), lerp(this.prevState.pos[1],target.pos[1],t), lerp(this.prevState.pos[2],target.pos[2],t)];
      tgt = [lerp(this.prevState.tgt[0],target.tgt[0],t), lerp(this.prevState.tgt[1],target.tgt[1],t), lerp(this.prevState.tgt[2],target.tgt[2],t)];
      roll = lerp(this.prevState.roll, target.roll, t);
      fov = lerp(this.prevState.fov, target.fov, t);
    } else {
      pos = target.pos.slice(); tgt = target.tgt.slice();
      roll = target.roll; fov = target.fov;
    }

    // Offset by dancer position
    pos[0] += fx; pos[2] += fz;
    tgt[0] += fx; tgt[2] += fz;

    this.applyCamera(pos, tgt, roll, fov);

    // MV #2: Handheld shake - observer is dynamic, presenter is deliberate
    const shakeBase = this.cameraRole === 'presenter' ? 0.001 : 0.003;
    const sh = shakeBase + audio.overall * 0.006;
    this.camera.position.x += Math.sin(time*17.3) * sh;
    this.camera.position.y += Math.sin(time*13.7) * sh;
  }
}

// ============================================================
// DANCE ENGINE - SMOOTH & FULL-BODY
// ============================================================
class DanceEngine {
  constructor(timeOffset, startX) {
    this.vrm = null; this.bones = {}; this.time = 0; this.hipBaseY = 0;
    this.currentStyle = 'flow'; this.nextStyle = 'flow';
    this.styleBlend = 1; this.lastStyleChange = 0;
    this.styleNames = ['flow','bounce','robot','chaos','minimal'];
    this.accentStrength = 0;
    this.smoothed = {}; // temporal smoothing buffers per bone
    this.rootScene = null;
    this.stageX = startX || 0; this.stageZ = 0; // world position on stage
    this.timeOffset = timeOffset || 0;
    this.seedOffset = timeOffset > 0 ? 500 : 0;
    this.scaleTarget = 0; this.currentScale = 0; // for appear/disappear animation
    this.snapPose = null; this.snapTimer = 0;
  }

  init(vrm) {
    this.vrm = vrm;
    const B = THREE.VRMSchema.HumanoidBoneName;
    for (const n of ['Hips','Spine','UpperChest','Chest','Neck','Head',
      'LeftShoulder','LeftUpperArm','LeftLowerArm','LeftHand',
      'RightShoulder','RightUpperArm','RightLowerArm','RightHand',
      'LeftUpperLeg','LeftLowerLeg','LeftFoot','RightUpperLeg','RightLowerLeg','RightFoot']) {
      const bone = vrm.humanoid.getBoneNode(B[n]);
      if (bone) this.bones[n] = bone;
    }
    this.rootScene = vrm.scene;
    if (this.bones.Hips) { this.bones.Hips.rotation.y = Math.PI; this.hipBaseY = this.bones.Hips.position.y; }
  }

  changeStyle(name) {
    if (name && name !== this.currentStyle) this.nextStyle = name;
    else { const o = this.styleNames.filter(s=>s!==this.currentStyle); this.nextStyle = o[Math.floor(Math.random()*o.length)]; }
    this.styleBlend = 0; this.lastStyleChange = this.time;
  }

  update(dt, audio) {
    if (!this.vrm) return;
    this.time += dt;
    const t = this.time + this.timeOffset; // offset for unique animation

    // Beat accent (smooth rise, smooth decay)
    if (audio.beatDetected) this.accentStrength = Math.min(this.accentStrength + 0.5, 1.0);
    this.accentStrength *= (1 - dt * 4); // smooth decay
    if (this.accentStrength < 0.01) this.accentStrength = 0;

    // Style transition (use real time for timing, not offset)
    if (this.styleBlend < 1) { this.styleBlend = Math.min(1, this.styleBlend + dt/2.5); if (this.styleBlend >= 1) this.currentStyle = this.nextStyle; }
    if (this.time - this.lastStyleChange > 10) this.changeStyle();
    if (audio.beatDetected && this.time - this.lastStyleChange > 5 && Math.random() > 0.9) this.changeStyle();

    // Rest pose (arms lowered from T-pose)
    for (const [name, bone] of Object.entries(this.bones)) {
      if (name==='Hips') { bone.rotation.set(0,Math.PI,0); bone.position.y=this.hipBaseY; }
      else if (name==='LeftUpperArm') bone.rotation.set(0.2,0,-1.0);
      else if (name==='RightUpperArm') bone.rotation.set(0.2,0,1.0);
      else if (name==='LeftLowerArm') bone.rotation.set(0,0,0.15);
      else if (name==='RightLowerArm') bone.rotation.set(0,0,-0.15);
      else bone.rotation.set(0,0,0);
    }

    // Compute and blend styles
    const a = this.getStyle(this.currentStyle, t, audio);
    const b = this.getStyle(this.nextStyle, t, audio);
    const bl = smoothstep(0, 1, this.styleBlend);

    // Blend first, then add body wave (avoid double-applying during transition)
    const blended = {};
    const allBones = new Set([...Object.keys(a), ...Object.keys(b)]);
    for (const bn of allBones) {
      const ma = a[bn] || {}, mb = b[bn] || {};
      blended[bn] = {
        x: lerp(ma.x||0, mb.x||0, bl),
        y: lerp(ma.y||0, mb.y||0, bl),
        z: lerp(ma.z||0, mb.z||0, bl),
        posY: lerp(ma.posY||0, mb.posY||0, bl),
      };
    }

    // Body wave propagation (applied once after blending)
    const chain = ['Hips','Spine','UpperChest','Chest','Neck','Head'];
    const wI = 0.5 + audio.overall * 1.0;
    for (let i = 0; i < chain.length; i++) {
      const wt = t - i * 0.13;
      if (!blended[chain[i]]) blended[chain[i]] = {x:0,y:0,z:0,posY:0};
      blended[chain[i]].y += Math.sin(wt * 2.5) * 0.08 * wI;
      blended[chain[i]].z += Math.sin(wt * 1.8 + 1.5) * 0.05 * wI;
    }

    // Apply with temporal smoothing (eliminates 1-frame jumps)
    const accentMult = 1 + this.accentStrength * 0.35;
    const smoothRate = Math.min(1, dt * 8); // ~0.13 at 60fps → smooth interpolation

    // Snap pose: override blended targets, snap-in fast
    if (this.snapTimer > 0) {
      this.snapTimer -= dt;
      for (const [bn, rot] of Object.entries(this.snapPose || {})) {
        if (!blended[bn]) blended[bn] = {x:0,y:0,z:0,posY:0};
        if (rot.x !== undefined) blended[bn].x = rot.x;
        if (rot.y !== undefined) blended[bn].y = rot.y;
        if (rot.z !== undefined) blended[bn].z = rot.z;
        if (rot.posY !== undefined) blended[bn].posY = rot.posY;
      }
      if (this.snapTimer <= 0) this.snapPose = null;
    }

    for (const boneName of Object.keys(this.bones)) {
      const target = blended[boneName] || {x:0,y:0,z:0,posY:0};
      const tx = target.x * accentMult;
      const ty = target.y * accentMult;
      const tz = target.z * accentMult;
      const tposY = target.posY * accentMult;

      if (!this.smoothed[boneName]) this.smoothed[boneName] = {x:0,y:0,z:0,posY:0};
      const s = this.smoothed[boneName];

      // Snap bones: high rate = 瞬間スナップ / 通常ボーン: 滑らか
      const isSnapBone = this.snapTimer > 0 && this.snapPose && (boneName in this.snapPose);
      const rate = isSnapBone ? Math.min(1, dt * 40) : smoothRate;

      s.x = lerp(s.x, tx, rate);
      s.y = lerp(s.y, ty, rate);
      s.z = lerp(s.z, tz, rate);
      s.posY = lerp(s.posY, tposY, rate);

      const bone = this.bones[boneName];
      bone.rotation.x += s.x;
      bone.rotation.y += s.y;
      bone.rotation.z += s.z;
      if (boneName === 'Hips') bone.position.y += s.posY;
    }

    // Stage movement (wander across floor)
    const moveSpeeds = { flow: 0.25, bounce: 0.35, robot: 0.3, chaos: 0.5, minimal: 0.12 };
    const moveRanges = { flow: 2.0, bounce: 1.5, robot: 1.2, chaos: 2.5, minimal: 0.8 };
    const mSpd = moveSpeeds[this.currentStyle] || 0.25;
    const mRng = moveRanges[this.currentStyle] || 1.5;
    const targetStageX = organic(t * mSpd, 200 + this.seedOffset) * mRng;
    const targetStageZ = organic(t * mSpd * 0.7, 201 + this.seedOffset) * mRng * 0.6;
    this.stageX = lerp(this.stageX, targetStageX, Math.min(1, dt * 1.5));
    this.stageZ = lerp(this.stageZ, targetStageZ, Math.min(1, dt * 1.5));
    if (this.rootScene) {
      this.rootScene.position.x = this.stageX;
      this.rootScene.position.z = this.stageZ;
    }

    // Scale fade animation (appear / disappear)
    this.currentScale = lerp(this.currentScale, this.scaleTarget, Math.min(1, dt * 3));
    if (this.rootScene) {
      this.rootScene.scale.setScalar(this.currentScale);
      if (this.currentScale < 0.01 && this.scaleTarget === 0) this.rootScene.visible = false;
    }

    // Blinking & expression
    try {
      const blink = Math.pow(Math.max(0, Math.sin(t*0.4)*Math.sin(t*3.1)), 20);
      this.vrm.blendShapeProxy.setValue(THREE.VRMSchema.BlendShapePresetName.Blink, blink);
      this.vrm.blendShapeProxy.setValue(THREE.VRMSchema.BlendShapePresetName.A, audio.overall * 0.5);
      this.vrm.blendShapeProxy.update();
    } catch(e) {}
    if (this.vrm.update) this.vrm.update(dt);
  }

  triggerSnap() {
    if (this.snapTimer > 0.04) return;
    const s = Math.random() > 0.5 ? 1 : -1;
    const poses = [
      // Bow - 腰を折る
      { Hips:{x:0.62,posY:-0.04}, Spine:{x:0.52}, Chest:{x:0.38}, UpperChest:{x:0.26},
        LeftUpperArm:{z:0.3}, RightUpperArm:{z:-0.3} },
      // BackArch - 後ろ反り
      { Hips:{x:-0.48}, Spine:{x:-0.4}, UpperChest:{x:-0.3}, Head:{x:-0.35} },
      // SideLean - 急傾斜
      { Hips:{z:s*0.52}, Spine:{z:-s*0.44}, UpperChest:{z:-s*0.34},
        LeftUpperArm:{x:0.1, z:s > 0 ? 0.5 : -0.15}, RightUpperArm:{x:0.1, z:s > 0 ? 0.15 : -0.5} },
      // ArmsUp - 両手を突き上げる
      { LeftUpperArm:{x:-1.35,z:0.4}, RightUpperArm:{x:-1.35,z:-0.4},
        LeftLowerArm:{z:0.25}, RightLowerArm:{z:-0.25} },
      // HeadSnap - 頭を急に向く
      { Head:{y:s*0.7, x:-0.2}, Neck:{y:s*0.38} },
      // Squat - 腰をストンと落とす
      { Hips:{posY:-0.14}, LeftUpperLeg:{x:0.35}, RightUpperLeg:{x:0.35},
        LeftLowerLeg:{x:-0.3}, RightLowerLeg:{x:-0.3} },
      // Twist - 上半身をひねる
      { Spine:{y:s*0.68}, UpperChest:{y:s*0.78}, Chest:{y:s*0.55}, Head:{y:-s*0.48} },
      // OneArmUp - 片腕だけ突き上げ
      ...(s > 0
        ? [{ LeftUpperArm:{x:-1.45,z:0.45}, RightUpperArm:{x:0.08,z:-0.1} }]
        : [{ RightUpperArm:{x:-1.45,z:-0.45}, LeftUpperArm:{x:0.08,z:0.1} }]),
    ];
    this.snapPose = poses[Math.floor(Math.random() * poses.length)];
    this.snapTimer = 0.08 + Math.random() * 0.32;
  }

  getStyle(name, t, au) {
    switch(name) {
      case 'flow': return this.flow(t, au);
      case 'bounce': return this.bounce(t, au);
      case 'robot': return this.robot(t, au);
      case 'chaos': return this.chaos(t, au);
      case 'minimal': return this.minimal(t, au);
      default: return this.flow(t, au);
    }
  }

  // --- FLOW: Sweeping, tai chi, large arcs ---
  flow(t, a) {
    const I = 0.8 + a.overall * 2.0;
    return {
      Hips: { x: organic(t*0.6,1)*0.2*I, y: organic(t*0.4,2)*0.35*I, z: organic(t*0.5,3)*0.12*I, posY: Math.sin(t*1.5)*0.04*I },
      Spine: { x: organic(t*0.7,4)*0.2*I, y: organic(t*0.5,5)*0.25*I, z: organic(t*0.6,6)*0.15*I },
      UpperChest: { x: organic(t*0.75,7.5)*0.12*I, y: organic(t*0.45,8.5)*0.15*I, z: organic(t*0.6,9.5)*0.1*I },
      Chest: { x: organic(t*0.8,7)*0.15*I, y: organic(t*0.4,8)*0.2*I, z: organic(t*0.65,9)*0.12*I },
      Neck: { x: organic(t*0.9,10)*0.2*I, y: organic(t*0.7,11)*0.3*I, z: organic(t*0.8,12)*0.12*I },
      Head: { x: organic(t*1.0,13)*0.15*I, y: organic(t*0.6,14)*0.22*I, z: organic(t*0.75,15)*0.1*I },
      LeftShoulder: { z: organic(t*0.5,16)*0.2*I },
      RightShoulder: { z: organic(t*0.5,17)*-0.2*I },
      LeftUpperArm: { x: organic(t*0.7,18)*0.5*I, y: organic(t*0.4,20)*0.35*I, z: 0.6+organic(t*0.5,19)*0.8*I+a.lowMid*0.5 },
      RightUpperArm: { x: organic(t*0.7,21)*0.5*I, y: organic(t*0.4,23)*-0.35*I, z: -0.6+organic(t*0.5,22)*-0.8*I-a.lowMid*0.5 },
      LeftLowerArm: { y: organic(t*0.6,25)*0.35*I, z: 0.25+organic(t*0.8,24)*0.5*I },
      RightLowerArm: { y: organic(t*0.6,27)*-0.35*I, z: -0.25+organic(t*0.8,26)*-0.5*I },
      LeftHand: { x: organic(t*0.9,50)*0.35*I, y: organic(t*0.7,54)*0.2*I, z: organic(t*0.7,51)*0.3*I },
      RightHand: { x: organic(t*0.9,52)*0.35*I, y: organic(t*0.7,55)*-0.2*I, z: organic(t*0.7,53)*-0.3*I },
      LeftUpperLeg: { x: organic(t*0.5,28)*-0.25*I, y: organic(t*0.3,34)*0.1*I, z: organic(t*0.4,29)*0.1*I },
      RightUpperLeg: { x: organic(t*0.5,30)*-0.25*I, y: organic(t*0.3,35)*-0.1*I, z: organic(t*0.4,31)*-0.1*I },
      LeftLowerLeg: { x: Math.max(0,organic(t*0.5,32))*0.35*I },
      RightLowerLeg: { x: Math.max(0,organic(t*0.5,33))*0.35*I },
      LeftFoot: { x: organic(t*0.6,36)*0.15*I, z: organic(t*0.5,37)*0.1*I },
      RightFoot: { x: organic(t*0.6,38)*0.15*I, z: organic(t*0.5,39)*-0.1*I },
    };
  }

  // --- BOUNCE: Hip-hop, hard-hitting ---
  bounce(t, a) {
    const I = 0.8 + a.overall * 2.0;
    const beat = a.bass;
    const bn = Math.abs(Math.sin(t*3.5)) * beat;
    return {
      Hips: { x: 0, y: organic(t*0.6,40)*0.25*I, z: 0, posY: -bn*0.12 },
      Spine: { x: -bn*0.2, y: organic(t*1,41)*0.2, z: Math.sin(t*1.5)*0.1*I },
      UpperChest: { x: bn*0.08, y: organic(t*0.9,41.5)*0.1*I },
      Chest: { x: bn*0.1, z: Math.sin(t*1.5+0.5)*0.08*I },
      Neck: { x: bn*0.15, y: organic(t*0.8,43)*0.2*I },
      Head: { x: -bn*0.25, y: organic(t*1.1,44)*0.2, z: organic(t*0.7,45)*0.1 },
      LeftShoulder: { z: bn*0.2 },
      RightShoulder: { z: -bn*0.2 },
      LeftUpperArm: { x: Math.sin(t*1.8)*0.4*I, y: organic(t*0.5,46)*0.2*I, z: 0.7+Math.sin(t*3.5)*0.6*I+a.highMid*0.6 },
      RightUpperArm: { x: Math.sin(t*1.8+Math.PI)*0.4*I, y: organic(t*0.5,47)*-0.2*I, z: -0.7-Math.sin(t*3.5+Math.PI)*0.6*I-a.highMid*0.6 },
      LeftLowerArm: { y: organic(t*0.7,48)*0.2*I, z: 0.5+Math.sin(t*3.5)*0.6*beat },
      RightLowerArm: { y: organic(t*0.7,49)*-0.2*I, z: -0.5-Math.sin(t*3.5)*0.6*beat },
      LeftHand: { x: Math.sin(t*3.5)*0.3*beat, z: organic(t*0.8,56)*0.2*I },
      RightHand: { x: Math.sin(t*3.5+Math.PI)*0.3*beat, z: organic(t*0.8,57)*-0.2*I },
      LeftUpperLeg: { x: Math.sin(t*3.5)*-0.3*I, y: organic(t*0.4,58)*0.08*I, z: Math.sin(t*1.8)*0.06*I },
      RightUpperLeg: { x: Math.sin(t*3.5+Math.PI)*-0.3*I, y: organic(t*0.4,59)*-0.08*I, z: Math.sin(t*1.8+1)*-0.06*I },
      LeftLowerLeg: { x: Math.max(0,Math.sin(t*3.5))*0.5*beat },
      RightLowerLeg: { x: Math.max(0,Math.sin(t*3.5+Math.PI))*0.5*beat },
      LeftFoot: { x: Math.sin(t*3.5)*0.15*I, z: bn*0.1 },
      RightFoot: { x: Math.sin(t*3.5+Math.PI)*0.15*I, z: -bn*0.1 },
    };
  }

  // --- ROBOT: Quantized, mechanical, isolation ---
  robot(t, a) {
    const I = 0.7 + a.overall * 1.5;
    const step = 0.25;
    const qt = Math.floor(t/step)*step;
    const snap = smoothstep(0, 0.3, (t-qt)/step);
    const r1=Math.sin(qt*2.3),r2=Math.sin(qt*3.1),r3=Math.sin(qt*1.7),r4=Math.sin(qt*2.9),r5=Math.sin(qt*1.3);
    return {
      Hips: { y: r1*0.4*I*snap, z: r5*0.1*snap, posY: -Math.abs(r1)*0.04*I },
      Spine: { x: r2*0.15*I*snap, y: r1*0.25*snap, z: r3*0.12*snap },
      UpperChest: { x: r3*0.1*snap, y: r5*0.15*snap },
      Chest: { y: r2*0.15*snap, z: r4*0.08*snap },
      Neck: { x: r3*0.2*snap, y: r4*0.3*snap, z: r5*0.1*snap },
      Head: { x: r4*0.15*snap, y: r3*0.25*snap, z: r2*0.15*snap },
      LeftShoulder: { z: r1*0.15*snap },
      RightShoulder: { z: -r1*0.15*snap },
      LeftUpperArm: { x: r2*0.6*I*snap, y: r4*0.4*snap, z: 0.3+r3*0.8*I*snap },
      RightUpperArm: { x: r3*0.6*I*snap, y: -r2*0.4*snap, z: -0.3-r4*0.8*I*snap },
      LeftLowerArm: { y: r5*0.3*snap, z: 0.3+Math.max(0,r1)*1.0*snap },
      RightLowerArm: { y: -r5*0.3*snap, z: -0.3-Math.max(0,r2)*1.0*snap },
      LeftHand: { x: r4*0.3*snap, y: r2*0.25*snap, z: r3*0.2*snap },
      RightHand: { x: r3*0.3*snap, y: -r4*0.25*snap, z: -r2*0.2*snap },
      LeftUpperLeg: { x: r1>0.3?-0.4*snap:r5*0.1*snap, y: r3*0.08*snap, z: r2*0.06*snap },
      RightUpperLeg: { x: r1<-0.3?-0.4*snap:r4*0.1*snap, y: -r3*0.08*snap, z: -r2*0.06*snap },
      LeftLowerLeg: { x: r1>0.3?0.6*snap:Math.max(0,r4)*0.15*snap },
      RightLowerLeg: { x: r1<-0.3?0.6*snap:Math.max(0,r3)*0.15*snap },
      LeftFoot: { x: r2*0.2*snap, z: r1>0.3?0.15*snap:0 },
      RightFoot: { x: r3*0.2*snap, z: r1<-0.3?-0.15*snap:0 },
    };
  }

  // --- CHAOS: Maximum energy, glitch ---
  chaos(t, a) {
    const I = 1.2 + a.overall * 3.0;
    return {
      Hips: { x: organic(t*2.5,60)*0.3*I, y: organic(t*2,61)*0.5*I, z: organic(t*2.2,62)*0.25*I, posY: Math.sin(t*5)*0.07*I },
      Spine: { x: organic(t*2.8,63)*0.3*I, y: organic(t*2.2,64)*0.35*I, z: organic(t*2.5,65)*0.25*I },
      UpperChest: { x: organic(t*3,93)*0.2*I, y: organic(t*2.3,94)*0.25*I, z: organic(t*2.6,95)*0.15*I },
      Chest: { x: organic(t*3,66)*0.25*I, y: organic(t*2,67)*0.3*I, z: organic(t*2.7,68)*0.2*I },
      Neck: { x: organic(t*3.5,69)*0.3*I, y: organic(t*3,70)*0.35*I, z: organic(t*3.2,71)*0.2*I },
      Head: { x: organic(t*4,72)*0.25*I, y: organic(t*2.5,73)*0.3*I, z: organic(t*3,74)*0.2*I },
      LeftShoulder: { z: organic(t*2.5,75)*0.3*I },
      RightShoulder: { z: organic(t*2.5,76)*-0.3*I },
      LeftUpperArm: { x: organic(t*2.2,77)*0.7*I, y: organic(t*2.5,79)*0.6*I, z: organic(t*2,78)*1.2*I+a.bass*0.8 },
      RightUpperArm: { x: organic(t*2.2,80)*0.7*I, y: organic(t*2.5,82)*-0.6*I, z: organic(t*2,81)*-1.2*I-a.bass*0.8 },
      LeftLowerArm: { y: organic(t*2.5,84)*0.5*I, z: organic(t*3,83)*0.7*I },
      RightLowerArm: { y: organic(t*2.5,86)*-0.5*I, z: organic(t*3,85)*-0.7*I },
      LeftHand: { x: organic(t*3,96)*0.4*I, y: organic(t*2.5,97)*0.35*I, z: organic(t*2.8,98)*0.3*I },
      RightHand: { x: organic(t*3,99)*0.4*I, y: organic(t*2.5,100)*-0.35*I, z: organic(t*2.8,101)*-0.3*I },
      LeftUpperLeg: { x: organic(t*2,87)*-0.35*I, y: organic(t*1.5,102)*0.15*I, z: organic(t*1.5,88)*0.15*I },
      RightUpperLeg: { x: organic(t*2,89)*-0.35*I, y: organic(t*1.5,103)*-0.15*I, z: organic(t*1.5,90)*-0.15*I },
      LeftLowerLeg: { x: Math.max(0,organic(t*2.5,91))*0.6*I },
      RightLowerLeg: { x: Math.max(0,organic(t*2.5,92))*0.6*I },
      LeftFoot: { x: organic(t*2.2,104)*0.25*I, y: organic(t*1.8,105)*0.15*I, z: organic(t*2,106)*0.2*I },
      RightFoot: { x: organic(t*2.2,107)*0.25*I, y: organic(t*1.8,108)*-0.15*I, z: organic(t*2,109)*-0.2*I },
    };
  }

  // --- MINIMAL: Breathing, micro-movement, but still full-body ---
  minimal(t, a) {
    const I = 0.4 + a.overall * 0.6;
    return {
      Hips: { y: organic(t*0.25,110)*0.06*I, z: organic(t*0.2,111)*0.04*I, posY: Math.sin(t*0.8)*0.01 },
      Spine: { x: organic(t*0.35,112)*0.04*I, y: organic(t*0.2,113)*0.03*I, z: organic(t*0.3,114)*0.03*I },
      UpperChest: { x: organic(t*0.3,115)*0.03*I },
      Chest: { x: Math.sin(t*0.5)*0.02 },
      Neck: { x: organic(t*0.4,116)*0.06*I, y: organic(t*0.3,117)*0.1*I },
      Head: { x: organic(t*0.5,118)*0.05*I, y: organic(t*0.35,119)*0.08*I, z: organic(t*0.4,120)*0.04*I },
      LeftShoulder: { z: organic(t*0.25,121)*0.03*I },
      RightShoulder: { z: organic(t*0.25,122)*-0.03*I },
      LeftUpperArm: { x: organic(t*0.3,123)*0.04*I, z: organic(t*0.35,124)*0.06*I },
      RightUpperArm: { x: organic(t*0.3,125)*0.04*I, z: organic(t*0.35,126)*-0.06*I },
      LeftLowerArm: { z: organic(t*0.3,127)*0.03*I },
      RightLowerArm: { z: organic(t*0.3,128)*-0.03*I },
      LeftHand: { x: organic(t*0.4,129)*0.04*I, z: organic(t*0.35,130)*0.03*I },
      RightHand: { x: organic(t*0.4,131)*0.04*I, z: organic(t*0.35,132)*-0.03*I },
      LeftUpperLeg: { x: organic(t*0.2,133)*-0.03*I, z: organic(t*0.15,134)*0.02*I },
      RightUpperLeg: { x: organic(t*0.2,135)*-0.03*I, z: organic(t*0.15,136)*-0.02*I },
      LeftLowerLeg: { x: Math.max(0,organic(t*0.25,137))*0.04*I },
      RightLowerLeg: { x: Math.max(0,organic(t*0.25,138))*0.04*I },
      LeftFoot: { x: organic(t*0.3,139)*0.03*I },
      RightFoot: { x: organic(t*0.3,140)*0.03*I },
    };
  }
}

// ============================================================
// WORLD GENERATOR - Procedural stages
// ============================================================
const WORLD_TYPES = ['crystal','ruins','neon','organic','tower','void','sunset','underwater','aurora','disco','lava'];
const worldConfigs = {
  crystal:    { bgColor: 0x1a0055, fogColor: 0x100038, fogDensity: 0.035 },
  ruins:      { bgColor: 0x1a1210, fogColor: 0x0e0a08, fogDensity: 0.05  },
  neon:       { bgColor: 0x0d0040, fogColor: 0x080028, fogDensity: 0.025 },
  organic:    { bgColor: 0x0a2e12, fogColor: 0x06200c, fogDensity: 0.045 },
  tower:      { bgColor: 0x10102a, fogColor: 0x0a0a20, fogDensity: 0.055 },
  void:       { bgColor: 0x0c0030, fogColor: 0x080020, fogDensity: 0.015 },
  sunset:     { bgColor: 0x7a2205, fogColor: 0x501604, fogDensity: 0.045 },
  underwater: { bgColor: 0x004e6e, fogColor: 0x003a55, fogDensity: 0.05  },
  aurora:     { bgColor: 0x0c2040, fogColor: 0x081830, fogDensity: 0.018 },
  disco:      { bgColor: 0x380068, fogColor: 0x280050, fogDensity: 0.04  },
  lava:       { bgColor: 0x580c00, fogColor: 0x3e0800, fogDensity: 0.045 },
};

class WorldGenerator {
  constructor(scene) {
    this.scene = scene;
    this.objects = [];
    this.currentType = '';
  }

  build(type) {
    this.objects.forEach(o => this.scene.remove(o));
    this.objects = [];
    this.currentType = type;
    this['_' + type]();
    const cfg = worldConfigs[type];
    this.scene.background.setHex(cfg.bgColor);
    this.scene.fog.color.setHex(cfg.fogColor);
    this.scene.fog.density = cfg.fogDensity;
  }

  _add(mesh) { this.scene.add(mesh); this.objects.push(mesh); return mesh; }
  _mat(opts) { return new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.85, ...opts }); }

  _crystal() {
    for (let i = 0; i < 22; i++) {
      const h = 1.5 + Math.random() * 5;
      const geom = new THREE.ConeGeometry(0.07 + Math.random() * 0.2, h, 3 + Math.floor(Math.random() * 3));
      const hue = 0.55 + Math.random() * 0.15;
      const m = this._add(new THREE.Mesh(geom, this._mat({
        color: new THREE.Color().setHSL(hue, 0.8, 0.25),
        emissive: new THREE.Color().setHSL(hue, 1, 0.12),
        specular: new THREE.Color().setHSL(hue, 1, 0.8), shininess: 200,
      })));
      const r = 3 + Math.random() * 8, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.4 + Math.random(); m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
    for (let i = 0; i < 14; i++) {
      const s = 0.12 + Math.random() * 0.3;
      const hue = 0.55 + Math.random() * 0.2;
      const m = this._add(new THREE.Mesh(new THREE.OctahedronGeometry(s), this._mat({
        color: new THREE.Color().setHSL(hue, 1, 0.5), emissive: new THREE.Color().setHSL(hue, 1, 0.25), shininess: 150,
      })));
      m.position.set((Math.random() - 0.5) * 14, 1 + Math.random() * 3.5, (Math.random() - 0.5) * 14);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.5 + Math.random(); m.userData.floatOffset = Math.random() * Math.PI * 2;
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.8;
    }
  }

  _ruins() {
    for (let i = 0; i < 14; i++) {
      const h = 0.5 + Math.random() * 4;
      const m = this._add(new THREE.Mesh(
        new THREE.CylinderGeometry(0.12 + Math.random() * 0.22, 0.18 + Math.random() * 0.1, h, 6 + Math.floor(Math.random() * 6)),
        this._mat({ color: new THREE.Color().setHSL(0, 0, 0.08 + Math.random() * 0.1), specular: 0x111122, shininess: 30 })
      ));
      const r = 2 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
      m.rotation.z = (Math.random() - 0.5) * 0.35;
    }
    for (let i = 0; i < 9; i++) {
      const w = 0.8 + Math.random() * 3, d = 0.8 + Math.random() * 3;
      const m = this._add(new THREE.Mesh(
        new THREE.BoxGeometry(w, 0.12 + Math.random() * 0.28, d),
        this._mat({ color: new THREE.Color().setHSL(0, 0, 0.07 + Math.random() * 0.08), specular: 0x222233, shininess: 50 })
      ));
      const r = 1.5 + Math.random() * 6, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, Math.random() * 0.4, Math.sin(a) * r);
      m.rotation.y = Math.random() * Math.PI;
    }
  }

  _neon() {
    for (let i = 0; i < 20; i++) {
      const w = 0.3 + Math.random() * 1.5, h = 0.5 + Math.random() * 3.5;
      const hue = Math.random();
      const m = this._add(new THREE.Mesh(
        new THREE.PlaneGeometry(w, h),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.6), side: THREE.DoubleSide, transparent: true, opacity: 0.45 })
      ));
      const r = 2 + Math.random() * 8, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.5 + Math.random() * 4, Math.sin(a) * r);
      m.rotation.y = a + Math.PI / 2; m.rotation.x = (Math.random() - 0.5) * 0.3;
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.3;
    }
    for (let i = 0; i < 12; i++) {
      const hue = Math.random();
      const m = this._add(new THREE.Mesh(
        new THREE.BoxGeometry(0.04, 2 + Math.random() * 5, 0.04),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.9), transparent: true, opacity: 0.85 })
      ));
      const r = 2 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 1.5 + Math.random() * 2, Math.sin(a) * r);
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.25;
    }
  }

  _organic() {
    for (let i = 0; i < 18; i++) {
      const s = 0.25 + Math.random() * 1.2, detail = Math.floor(Math.random() * 3);
      const hue = 0.25 + Math.random() * 0.35, wire = Math.random() > 0.55;
      const m = this._add(new THREE.Mesh(
        new THREE.IcosahedronGeometry(s, detail),
        this._mat({ color: new THREE.Color().setHSL(hue, 0.6, wire ? 0.4 : 0.2),
          emissive: new THREE.Color().setHSL(hue, 0.8, 0.08),
          specular: new THREE.Color().setHSL(hue, 0.8, 0.5), shininess: 80, wireframe: wire })
      ));
      const r = 2 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.3 + Math.random() * 3, Math.sin(a) * r);
      m.userData.baseY = m.position.y;
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.4; m.userData.rotSpeedX = (Math.random() - 0.5) * 0.2;
      m.userData.floatSpeed = 0.3 + Math.random() * 0.5; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
  }

  _tower() {
    for (let i = 0; i < 20; i++) {
      const w = 0.3 + Math.random() * 1.2, h = 2 + Math.random() * 9, d = 0.3 + Math.random() * 1.2;
      const g = 0.04 + Math.random() * 0.12;
      const m = this._add(new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        this._mat({ color: new THREE.Color(g, g, g * 1.3), specular: 0x1a1a2e, shininess: 60 })
      ));
      const r = 3 + Math.random() * 8, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
    }
    for (let i = 0; i < 28; i++) {
      const warm = Math.random() > 0.4;
      const m = this._add(new THREE.Mesh(
        new THREE.PlaneGeometry(0.12, 0.08),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(warm ? 0.12 : 0.0, 0.8, 0.85), transparent: true, opacity: 0.7 })
      ));
      const r = 3.5 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.5 + Math.random() * 6, Math.sin(a) * r);
      m.rotation.y = a + Math.PI / 2;
    }
  }

  _void() {
    for (let i = 0; i < 14; i++) {
      const w = 0.5 + Math.random() * 2.5, d = 0.5 + Math.random() * 2.5;
      const hue = 0.65 + Math.random() * 0.3;
      const m = this._add(new THREE.Mesh(
        new THREE.BoxGeometry(w, 0.08 + Math.random() * 0.14, d),
        this._mat({ color: new THREE.Color().setHSL(hue, 0.4, 0.12),
          emissive: new THREE.Color().setHSL(hue, 1, 0.04),
          specular: new THREE.Color().setHSL(hue, 0.8, 0.5), shininess: 120 })
      ));
      const r = 2 + Math.random() * 8, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.5 + Math.random() * 4, Math.sin(a) * r);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.2 + Math.random() * 0.4; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
    for (let i = 0; i < 10; i++) {
      const hue = 0.7 + Math.random() * 0.2;
      const m = this._add(new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.3 + Math.random() * 0.8, 1),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.5), wireframe: true, transparent: true, opacity: 0.4 })
      ));
      m.position.set((Math.random() - 0.5) * 14, 1 + Math.random() * 4, (Math.random() - 0.5) * 14);
      m.userData.baseY = m.position.y;
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.4;
      m.userData.floatSpeed = 0.3 + Math.random() * 0.5; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
  }

  _sunset() {
    // Low horizon silhouette structures
    for (let i = 0; i < 16; i++) {
      const w = 0.5 + Math.random() * 2, h = 1 + Math.random() * 5, d = 0.5 + Math.random() * 1.5;
      const dark = 0.03 + Math.random() * 0.05;
      const m = this._add(new THREE.Mesh(new THREE.BoxGeometry(w, h, d),
        this._mat({ color: new THREE.Color(dark, dark * 0.5, dark * 0.3), specular: 0x221106, shininess: 20 })));
      const r = 4 + Math.random() * 8, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
    }
    // Sun-ray pillars with warm glow
    for (let i = 0; i < 10; i++) {
      const h = 3 + Math.random() * 6;
      const hue = 0.05 + Math.random() * 0.08;
      const m = this._add(new THREE.Mesh(new THREE.BoxGeometry(0.05, h, 0.05),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.7), transparent: true, opacity: 0.5 })));
      const r = 2 + Math.random() * 9, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.1;
    }
    // Floating emissive orbs like distant suns
    for (let i = 0; i < 6; i++) {
      const s = 0.2 + Math.random() * 0.5;
      const hue = 0.05 + Math.random() * 0.1;
      const m = this._add(new THREE.Mesh(new THREE.SphereGeometry(s, 8, 8),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.85), transparent: true, opacity: 0.8 })));
      const r = 4 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 1.5 + Math.random() * 4, Math.sin(a) * r);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.3 + Math.random() * 0.3; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
  }

  _underwater() {
    // Large translucent orb formations
    for (let i = 0; i < 12; i++) {
      const s = 0.3 + Math.random() * 1.2;
      const hue = 0.48 + Math.random() * 0.12;
      const m = this._add(new THREE.Mesh(new THREE.SphereGeometry(s, 10, 10),
        this._mat({ color: new THREE.Color().setHSL(hue, 0.7, 0.25), emissive: new THREE.Color().setHSL(hue, 0.8, 0.08), specular: new THREE.Color().setHSL(hue, 1, 0.7), shininess: 150, opacity: 0.65 })));
      const r = 3 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.5 + Math.random() * 3, Math.sin(a) * r);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.25 + Math.random() * 0.35; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
    // Thin seaweed/kelp strips
    for (let i = 0; i < 14; i++) {
      const h = 1.5 + Math.random() * 3.5;
      const hue = 0.35 + Math.random() * 0.15;
      const m = this._add(new THREE.Mesh(new THREE.BoxGeometry(0.06, h, 0.06),
        this._mat({ color: new THREE.Color().setHSL(hue, 0.8, 0.25), emissive: new THREE.Color().setHSL(hue, 0.8, 0.05) })));
      const r = 2 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.15;
    }
    // Bubble particles (small bright orbs floating up)
    for (let i = 0; i < 20; i++) {
      const s = 0.04 + Math.random() * 0.1;
      const m = this._add(new THREE.Mesh(new THREE.SphereGeometry(s, 6, 6),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.53, 0.6, 0.85), transparent: true, opacity: 0.55 })));
      m.position.set((Math.random() - 0.5) * 14, Math.random() * 5, (Math.random() - 0.5) * 14);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.6 + Math.random() * 0.8; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
  }

  _aurora() {
    // Aurora curtain ribbons high in the sky
    const auroraColors = [[0.38, 1, 0.6], [0.55, 1, 0.55], [0.82, 1, 0.6], [0.16, 1, 0.55]];
    for (let i = 0; i < 18; i++) {
      const w = 1 + Math.random() * 3, h = 4 + Math.random() * 5;
      const col = auroraColors[Math.floor(Math.random() * auroraColors.length)];
      const m = this._add(new THREE.Mesh(new THREE.PlaneGeometry(w, h, 1, 6),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(col[0], col[1], col[2]), side: THREE.DoubleSide, transparent: true, opacity: 0.18 + Math.random() * 0.2 })));
      const r = 4 + Math.random() * 9, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 3 + Math.random() * 3, Math.sin(a) * r);
      m.rotation.y = a;
      m.userData.rotSpeedY = (Math.random() - 0.5) * 0.04;
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.15 + Math.random() * 0.2; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
    // Ground ice panels
    for (let i = 0; i < 10; i++) {
      const w = 0.5 + Math.random() * 2.5, d = 0.5 + Math.random() * 2.5;
      const hue = 0.5 + Math.random() * 0.15;
      const m = this._add(new THREE.Mesh(new THREE.BoxGeometry(w, 0.05, d),
        this._mat({ color: new THREE.Color().setHSL(hue, 0.5, 0.15), specular: new THREE.Color().setHSL(hue, 0.8, 0.7), shininess: 200, opacity: 0.7 })));
      const r = 2 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.025, Math.sin(a) * r);
    }
  }

  _disco() {
    // Central disco ball cluster
    for (let phi = 0; phi < Math.PI; phi += 0.35) {
      for (let theta = 0; theta < Math.PI * 2; theta += 0.45) {
        const s = 0.12;
        const m = this._add(new THREE.Mesh(new THREE.BoxGeometry(s, s, s),
          new THREE.MeshPhongMaterial({ color: 0xcccccc, specular: 0xffffff, shininess: 300, transparent: true, opacity: 0.9 })));
        const r = 1.2;
        m.position.set(Math.sin(phi) * Math.cos(theta) * r + 0, Math.cos(phi) * r + 3, Math.sin(phi) * Math.sin(theta) * r);
        m.userData.rotSpeedY = 0.3;
        m.userData.baseY = m.position.y;
        m.userData.floatSpeed = 0.2; m.userData.floatOffset = phi;
      }
    }
    // Spinning colored panels
    for (let i = 0; i < 16; i++) {
      const w = 0.4 + Math.random() * 1.5, h = 0.4 + Math.random() * 1.5;
      const hue = Math.random();
      const m = this._add(new THREE.Mesh(new THREE.PlaneGeometry(w, h),
        new THREE.MeshPhongMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.5), specular: 0xffffff, shininess: 200, side: THREE.DoubleSide, transparent: true, opacity: 0.7 })));
      const r = 3 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, 0.5 + Math.random() * 3, Math.sin(a) * r);
      m.rotation.y = a;
      m.userData.rotSpeedY = (Math.random() - 0.5) * 1.5;
    }
  }

  _lava() {
    // Volcanic rocky platforms
    for (let i = 0; i < 12; i++) {
      const w = 0.5 + Math.random() * 3, h = 0.15 + Math.random() * 0.4, d = 0.5 + Math.random() * 3;
      const dark = 0.04 + Math.random() * 0.06;
      const m = this._add(new THREE.Mesh(new THREE.BoxGeometry(w, h, d),
        this._mat({ color: new THREE.Color(dark, dark * 0.3, 0), emissive: new THREE.Color(0.05, 0.01, 0), shininess: 10 })));
      const r = 2 + Math.random() * 7, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, Math.random() * 0.6, Math.sin(a) * r);
    }
    // Glowing lava crack planes
    for (let i = 0; i < 18; i++) {
      const w = 0.03 + Math.random() * 0.08, h = 0.2 + Math.random() * 1.5;
      const hue = 0.04 + Math.random() * 0.05;
      const m = this._add(new THREE.Mesh(new THREE.PlaneGeometry(w, h),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.6), side: THREE.DoubleSide, transparent: true, opacity: 0.85 })));
      const r = 1 + Math.random() * 8, a = Math.random() * Math.PI * 2;
      m.position.set(Math.cos(a) * r, h / 2, Math.sin(a) * r);
      m.rotation.y = a + (Math.random() - 0.5) * 0.5;
    }
    // Rising ember orbs
    for (let i = 0; i < 20; i++) {
      const s = 0.04 + Math.random() * 0.1;
      const hue = 0.03 + Math.random() * 0.07;
      const m = this._add(new THREE.Mesh(new THREE.SphereGeometry(s, 5, 5),
        new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.7), transparent: true, opacity: 0.8 })));
      m.position.set((Math.random() - 0.5) * 12, Math.random() * 4, (Math.random() - 0.5) * 12);
      m.userData.baseY = m.position.y;
      m.userData.floatSpeed = 0.8 + Math.random() * 1.2; m.userData.floatOffset = Math.random() * Math.PI * 2;
    }
  }

  update(time) {
    this.objects.forEach(o => {
      if (o.userData.baseY !== undefined && o.userData.floatSpeed) {
        o.position.y = o.userData.baseY + Math.sin(time * o.userData.floatSpeed + (o.userData.floatOffset || 0)) * 0.35;
      }
      if (o.userData.rotSpeedY) o.rotation.y += o.userData.rotSpeedY * 0.016;
      if (o.userData.rotSpeedX) o.rotation.x += o.userData.rotSpeedX * 0.016;
    });
  }
}

// ============================================================
// OVERLAY SYSTEM - 2D screen-space effects
// ============================================================
class OverlaySystem {
  constructor() {
    this.canvas = document.getElementById('canvas2d');
    this.ctx = this.canvas.getContext('2d');
    this.glitchBars = [];
    this.vignetteIntensity = 0;
    this.beatFlash = 0;
    this.beatFlashHue = 0;
    this.currentWorldType = 'crystal';
    // Film grain buffer (small, drawn scaled-up)
    this.grainCanvas = document.createElement('canvas');
    this.grainCanvas.width = 200;
    this.grainCanvas.height = 200;
    this.grainCtx = this.grainCanvas.getContext('2d');
    this.grainImageData = this.grainCtx.createImageData(200, 200);
    this._resize();
    window.addEventListener('resize', () => this._resize());
  }

  _resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  _drawGrain(intensity) {
    const d = this.grainImageData.data;
    for (let i = 0; i < d.length; i += 4) {
      const v = (Math.random() * 255) | 0;
      d[i] = v; d[i+1] = v; d[i+2] = v;
      d[i+3] = (Math.random() * intensity * 80) | 0;
    }
    this.grainCtx.putImageData(this.grainImageData, 0, 0);
    const ctx = this.ctx;
    const W = this.canvas.width, H = this.canvas.height;
    ctx.save();
    ctx.globalCompositeOperation = 'overlay';
    ctx.globalAlpha = intensity * 0.55;
    ctx.drawImage(this.grainCanvas, 0, 0, W, H);
    ctx.restore();
  }

  triggerBeat(bass) {
    const W = this.canvas.width, H = this.canvas.height;
    // Hard glitch bars on beat
    if (bass > 0.45) {
      const n = 1 + Math.floor(bass * 3);
      for (let i = 0; i < n; i++) {
        this.glitchBars.push({
          y: Math.random() * H, h: 1 + Math.random() * 10,
          life: 0.15 + Math.random() * 0.2,
          hue: Math.random() * 360,
        });
      }
    }
    this.vignetteIntensity = Math.min(1, this.vignetteIntensity + bass * 0.65);
    // Hard beat flash stamp (solid color rectangle, very brief)
    if (bass > 0.65) {
      this.beatFlash = bass * 0.7;
      this.beatFlashHue = Math.random() * 360;
    }
  }

  triggerWorldSwitch(worldType) {
    this.currentWorldType = worldType;
    // Hard screen flash (not confetti, just a sharp white cut)
    this.beatFlash = 1.5;
    this.beatFlashHue = Math.random() * 360;
  }

  update(dt, worldType) {
    const W = this.canvas.width, H = this.canvas.height;
    const ctx = this.ctx;
    ctx.clearRect(0, 0, W, H);

    // Subtle luminance modulation - avoids hard scanline stripes
    // Uses a very fine 1px pattern at low opacity so it reads as texture not retro gaming
    const scanStrength = { neon: 0.06, disco: 0.05, void: 0.05, tower: 0.04, ruins: 0.04 }[worldType] ?? 0.02;
    if (scanStrength > 0) {
      for (let y = 0; y < H; y += 3) {
        // Sine wave so adjacent lines have smooth luminance variation, not hard on/off
        const v = 0.5 + 0.5 * Math.sin((y / H) * Math.PI * 2 * (H / 6));
        ctx.fillStyle = `rgba(0,0,0,${scanStrength * v})`;
        ctx.fillRect(0, y, W, 1);
      }
    }

    // Beat flash - hard solid color stamp, rapidly decays
    if (this.beatFlash > 0.01) {
      this.beatFlash *= 0.78;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = Math.min(this.beatFlash, 0.55);
      ctx.fillStyle = `hsl(${this.beatFlashHue},100%,70%)`;
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }

    // Glitch bars - solid colored horizontal strips
    this.glitchBars = this.glitchBars.filter(bar => {
      bar.life -= dt * 8;
      if (bar.life <= 0) return false;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.globalAlpha = bar.life;
      ctx.fillStyle = `hsl(${bar.hue},100%,85%)`;
      ctx.fillRect(0, bar.y, W, bar.h);
      // Offset duplicate for chromatic split
      ctx.globalAlpha = bar.life * 0.35;
      ctx.fillStyle = `hsl(${(bar.hue + 180) % 360},100%,85%)`;
      ctx.fillRect(8, bar.y + bar.h * 0.4, W * 0.6, Math.max(1, bar.h * 0.3));
      ctx.restore();
      return true;
    });

    // Vignette - sharp edge, brief
    if (this.vignetteIntensity > 0.01) {
      this.vignetteIntensity *= 0.88;
      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      const grad = ctx.createRadialGradient(W/2, H/2, H*0.25, W/2, H/2, H*0.9);
      grad.addColorStop(0, 'rgba(0,0,0,0)');
      grad.addColorStop(1, `rgba(0,0,0,${this.vignetteIntensity * 0.65})`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);
      ctx.restore();
    }

    // Film grain
    const grainIntensity = {
      ruins: 0.55, lava: 0.5, organic: 0.45, void: 0.4, tower: 0.4,
      sunset: 0.35, crystal: 0.3, neon: 0.3, underwater: 0.25, aurora: 0.25, disco: 0.2,
    }[worldType] ?? 0.35;
    this._drawGrain(grainIntensity);
  }
}

// ============================================================
// SCENE SETUP
// ============================================================
const clock = new THREE.Clock();
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 1.5;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(30, window.innerWidth/window.innerHeight, 0.1, 50);
camera.position.set(0, 1.2, 4);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a0055);
scene.fog = new THREE.FogExp2(0x100038, 0.035);

// Floor
const floorGeom = new THREE.PlaneGeometry(30, 30);
const floorMat = new THREE.MeshPhongMaterial({ color: 0x050508, specular: 0x888899, shininess: 120 });
const floor = new THREE.Mesh(floorGeom, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

// Grid overlay
const grid = new THREE.GridHelper(24, 48, 0x181830, 0x0c0c1a);
scene.add(grid);

// World generator
const worldGen = new WorldGenerator(scene);
let worldSwitchTimer = 0;
let currentWorldIdx = 0;
worldGen.build(WORLD_TYPES[0]); // initial world

// ============================================================
// LIGHTING - MV STAGE (VIVID)
// ============================================================
const ambientLight = new THREE.AmbientLight(0x080010, 0.02); // very low to preserve shadow depth
scene.add(ambientLight);

// Main directional key light - MToon responds best to DirectionalLight
const keyLight = new THREE.DirectionalLight(0xffffff, 2.5);
keyLight.position.set(2, 4, 3);
keyLight.castShadow = true;
keyLight.shadow.mapSize.width = 2048;
keyLight.shadow.mapSize.height = 2048;
keyLight.shadow.camera.near = 0.5;
keyLight.shadow.camera.far = 30;
keyLight.shadow.camera.left = -6; keyLight.shadow.camera.right = 6;
keyLight.shadow.camera.top = 6; keyLight.shadow.camera.bottom = -6;
scene.add(keyLight);

// 6 focused spotlights for dramatic contrast
const spots = [];
const spotConfigs = [
  { pos: [3, 5, 3],    tgt: [0, 0.5, 0] },   // front-right high
  { pos: [-3, 5, 3],   tgt: [0, 0.5, 0] },   // front-left high
  { pos: [0, 4, -3],   tgt: [0, 0.8, 0] },   // back center
  { pos: [4, 3, -1],   tgt: [0, 0.5, 0] },   // side right
  { pos: [-4, 3, -1],  tgt: [0, 0.5, 0] },   // side left
  { pos: [0, 6, 0],    tgt: [0, 0, 0] },      // top down
];
for (let i = 0; i < spotConfigs.length; i++) {
  const cfg = spotConfigs[i];
  const spot = new THREE.SpotLight(0xffffff, 4, 20, Math.PI/7, 0.3, 1);
  spot.position.set(cfg.pos[0], cfg.pos[1], cfg.pos[2]);
  spot.target.position.set(cfg.tgt[0], cfg.tgt[1], cfg.tgt[2]);
  // Enable shadows on key lights (front-left, front-right, top-down)
  if (i < 3) {
    spot.castShadow = true;
    spot.shadow.mapSize.width = 1024;
    spot.shadow.mapSize.height = 1024;
    spot.shadow.camera.near = 0.5;
    spot.shadow.camera.far = 25;
  }
  scene.add(spot);
  scene.add(spot.target);
  spots.push(spot);
}

// Strong rim lights for silhouette edge
const rimL = new THREE.PointLight(0xff00ff, 4, 10);
rimL.position.set(-2.5, 2.5, -2.5);
scene.add(rimL);
const rimR = new THREE.PointLight(0x00ffff, 4, 10);
rimR.position.set(2.5, 2.5, -2.5);
scene.add(rimR);
// Low ground accent
const groundL = new THREE.PointLight(0xff0044, 2, 6);
groundL.position.set(-2, 0.1, 1);
scene.add(groundL);
const groundR = new THREE.PointLight(0x0044ff, 2, 6);
groundR.position.set(2, 0.1, 1);
scene.add(groundR);

// Color palettes for dramatic mood shifts
const palettes = [
  [[0,0.95,0.55],[0.55,0.95,0.5],[0.85,0.9,0.55],[0.15,0.9,0.5],[0.4,0.9,0.5],[0.7,0.85,0.5]], // rainbow spread
  [[0.95,1,0.6],[0.95,1,0.5],[0.0,0.9,0.5],[0.0,0.9,0.4],[0.95,0.8,0.55],[0.05,1,0.55]],        // fire (red/orange)
  [[0.55,1,0.55],[0.6,0.9,0.5],[0.65,1,0.45],[0.5,0.8,0.5],[0.58,0.9,0.55],[0.7,0.9,0.5]],       // ice (cyan/blue)
  [[0.83,1,0.6],[0.75,0.9,0.5],[0.9,1,0.55],[0.0,0.8,0.4],[0.83,0.9,0.5],[0.08,0.9,0.55]],       // neon (magenta/purple)
  [[0.12,1,0.55],[0.45,1,0.5],[0.12,0.9,0.45],[0.3,0.8,0.5],[0.08,0.9,0.55],[0.5,0.9,0.5]],      // toxic (green/cyan)
];
let currentPalette = 0;
let paletteBlend = 1;
let prevPalette = 0;

// ============================================================
// SPARKS - LineSegments fireworks
// ============================================================
const SPARK_COUNT = 200;
const sparkState = Array.from({length: SPARK_COUNT}, () => ({
  px: 0, py: 0, pz: 0, x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, life: 0, hue: 0,
}));
const sparkPos = new Float32Array(SPARK_COUNT * 6);
const sparkCol = new Float32Array(SPARK_COUNT * 6);
const sparkGeom = new THREE.BufferGeometry();
sparkGeom.addAttribute('position', new THREE.BufferAttribute(sparkPos, 3));
sparkGeom.addAttribute('color', new THREE.BufferAttribute(sparkCol, 3));
const sparkMat = new THREE.LineBasicMaterial({
  vertexColors: THREE.VertexColors,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false,
});
const sparkMesh = new THREE.LineSegments(sparkGeom, sparkMat);
// sparkMesh は scene には追加しない（空中パーティクル不要）

// ============================================================
// POST-PROCESSING
// ============================================================
let composer;
try {
  composer = new THREE.EffectComposer(renderer);
  composer.addPass(new THREE.RenderPass(scene, camera));
  composer.addPass(new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.6, 0.6
  ));
} catch(e) { composer = null; }

// ============================================================
// SYSTEMS
// ============================================================
const audio = new AudioSystem();
const camSys = new CameraSystem(camera);
const overlay = new OverlaySystem();
const POOL_SIZE = 3;
const dancerPool = Array.from({length: POOL_SIZE}, (_, i) => new DanceEngine(i * 100, 0));
let activeDancers = [];

function setActiveDancers(count) {
  const loaded = dancerPool.filter(d => d.rootScene);
  const n = Math.min(count, loaded.length);
  // Deactivate all first
  loaded.forEach(d => { d.scaleTarget = 0; });
  // Activate first n, spread around stage
  activeDancers = loaded.slice(0, n);
  activeDancers.forEach((d, i) => {
    d.rootScene.visible = true;
    d.scaleTarget = 1;
    const angle = (i / n) * Math.PI * 2;
    const r = n > 1 ? 1.5 : 0;
    d.stageX = Math.cos(angle) * r; d.stageZ = Math.sin(angle) * r * 0.5;
    d.rootScene.position.x = d.stageX; d.rootScene.position.z = d.stageZ;
  });
}

// MV #3: World-appropriate palette mapping (color story)
const worldPaletteMap = {
  crystal: 2, ruins: 0, neon: 3, organic: 4, tower: 3,
  void: 2, sunset: 1, underwater: 2, aurora: 2, disco: 0, lava: 1,
};

function switchWorld(time) {
  currentWorldIdx = Math.floor(Math.random() * WORLD_TYPES.length);
  worldGen.build(WORLD_TYPES[currentWorldIdx]);
  const counts = [1, 2, 2, 2, 3];
  setActiveDancers(counts[Math.floor(Math.random() * counts.length)]);
  activeDancers.forEach(d => { if (Math.random() > 0.5) d.changeStyle(); });
  overlay.triggerWorldSwitch(WORLD_TYPES[currentWorldIdx]);
  // MV #3: Snap to world-appropriate palette
  prevPalette = currentPalette;
  currentPalette = worldPaletteMap[WORLD_TYPES[currentWorldIdx]] ?? 0;
  paletteBlend = 0;
  lastPaletteChange = time;
  // MV #2/#4/#5: camera on world switch
  camSys.onWorldSwitch();
}

// ============================================================
// LOAD MODEL
// ============================================================
const loader = new THREE.GLTFLoader();
loader.crossOrigin = 'anonymous';
let loadedCount = 0;
dancerPool.forEach((dancer, idx) => {
  loader.load('./models/masawada.vrm',
    (gltf) => {
      THREE.VRM.from(gltf).then((vrm) => {
        scene.add(vrm.scene);
        dancer.init(vrm);
        vrm.scene.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = true; obj.receiveShadow = true;
            const mat = obj.material;
            if (mat && mat.shadeColor) mat.shadeColor.setHex(0x000000); // deep black in shadow
          }
        });
        vrm.scene.visible = false; // start hidden
        if (idx > 0) dancer.changeStyle();
        loadedCount++;
        document.getElementById('loading').textContent = `LOADING... ${loadedCount}/${POOL_SIZE}`;
        if (loadedCount >= POOL_SIZE) {
          document.getElementById('loading').style.display = 'none';
          setActiveDancers(2); // start with 2
        }
      });
    },
    idx === 0 ? (p) => { document.getElementById('loading').textContent = 'LOADING... ' + (100*p.loaded/p.total|0) + '%'; } : null,
    (e) => console.error(e)
  );
});

// ============================================================
// EFFECTS UPDATE
// ============================================================
let strobeFlash = 0;
let lastPaletteChange = 0;

function updateLights(time, au, dancers) {
  // Lights follow midpoint between dancers
  const fx = dancers.length > 1 ? (dancers[0].stageX + dancers[1].stageX) * 0.5 : dancers[0].stageX;
  const fz = dancers.length > 1 ? (dancers[0].stageZ + dancers[1].stageZ) * 0.5 : dancers[0].stageZ;
  // Palette switching (on beat or every ~6s)
  if (paletteBlend < 1) paletteBlend = Math.min(1, paletteBlend + 0.02);
  // MV #3: Slower palette changes — hold color story within world
  if ((au.beatDetected && time - lastPaletteChange > 14 && Math.random() > 0.75) || time - lastPaletteChange > 22) {
    prevPalette = currentPalette;
    currentPalette = (currentPalette + 1 + Math.floor(Math.random() * (palettes.length - 1))) % palettes.length;
    paletteBlend = 0;
    lastPaletteChange = time;
  }

  // Apply palette colors to spots with blend
  for (let i = 0; i < spots.length; i++) {
    const a = palettes[prevPalette][i] || palettes[prevPalette][0];
    const b = palettes[currentPalette][i] || palettes[currentPalette][0];
    const h = lerp(a[0], b[0], paletteBlend);
    const s = lerp(a[1], b[1], paletteBlend);
    const l = lerp(a[2], b[2], paletteBlend);
    spots[i].color.setHSL(h, s, l);

    // Intensity: high base + audio-reactive per spot
    const audioBoost = [au.bass, au.lowMid, au.highMid, au.bass, au.treble, au.overall][i] || au.overall;
    spots[i].intensity = 3 + audioBoost * 8;
  }

  // Sweep spot targets dramatically (following dancer)
  spots[0].target.position.x = fx + Math.sin(time * 0.8) * 2;
  spots[0].target.position.z = fz + Math.cos(time * 0.6) * 2;
  spots[1].target.position.x = fx + Math.sin(time * 0.7 + 2) * 2;
  spots[1].target.position.z = fz + Math.cos(time * 0.5 + 2) * 2;
  spots[2].target.position.x = fx;
  spots[2].target.position.z = fz;
  spots[3].target.position.x = fx + Math.sin(time * 0.4) * 1 + 1;
  spots[3].target.position.z = fz + Math.cos(time * 0.3) * 2;
  spots[4].target.position.x = fx + Math.sin(time * 0.4 + Math.PI) * 1 - 1;
  spots[4].target.position.z = fz + Math.cos(time * 0.3 + Math.PI) * 2;
  spots[5].target.position.x = fx;
  spots[5].target.position.z = fz;

  // Key light follows dancer for dramatic directional shading on MToon
  keyLight.position.set(fx + 2, 4, fz + 3);
  keyLight.target.position.set(fx, 1, fz);
  keyLight.target.updateMatrixWorld();
  keyLight.intensity = 1.5 + au.bass * 2.0;

  // Rim lights: strong contrasting colors (follow dancer)
  const rp = palettes[currentPalette];
  rimL.position.set(fx - 2.5, 2.5, fz - 2.5);
  rimR.position.set(fx + 2.5, 2.5, fz - 2.5);
  rimL.color.setHSL((rp[0][0] + 0.5) % 1, 1, 0.55);
  rimR.color.setHSL((rp[2][0] + 0.3) % 1, 1, 0.55);
  rimL.intensity = 3 + au.lowMid * 6;
  rimR.intensity = 3 + au.highMid * 6;

  // Ground accent lights (follow dancer)
  groundL.position.set(fx - 2, 0.1, fz + 1);
  groundR.position.set(fx + 2, 0.1, fz + 1);
  groundL.color.setHSL(rp[0][0], 1, 0.5);
  groundR.color.setHSL(rp[2][0], 1, 0.5);
  groundL.intensity = 1.5 + au.bass * 4;
  groundR.intensity = 1.5 + au.treble * 4;

  // STROBE - intense white flash on beat
  if (au.beatDetected) strobeFlash = 1.5;
  strobeFlash *= 0.8;
  ambientLight.intensity = 0.05 + strobeFlash * 4.0;
  ambientLight.color.setHSL(0, 0, 0.8 + strobeFlash * 0.2); // white strobe

  // Background flash on strong beats - blend with world base color
  const cfg = worldConfigs[worldGen.currentType] || worldConfigs.crystal;
  const baseBg = new THREE.Color(cfg.bgColor);
  if (strobeFlash > 0.3) {
    const flash = new THREE.Color().setHSL(rp[0][0], 0.6, strobeFlash * 0.3);
    scene.background.copy(baseBg).lerp(flash, Math.min(1, strobeFlash));
  } else {
    scene.background.copy(baseBg);
  }

  // Floor catches vivid specular
  const fp = rp[Math.floor(time * 0.5) % rp.length];
  floorMat.specular.setHSL(fp[0], 0.8, 0.25 + au.overall * 0.35);
}

function spawnBurst(cx, cy, cz, hue) {
  const n = 12 + Math.floor(Math.random() * 20);
  for (let i = 0; i < n; i++) {
    const angle = Math.random() * Math.PI * 2;
    const elev = (Math.random() - 0.25) * Math.PI * 0.75;
    const speed = 0.05 + Math.random() * 0.13;
    for (let j = 0; j < SPARK_COUNT; j++) {
      if (sparkState[j].life <= 0) {
        Object.assign(sparkState[j], {
          px: cx, py: cy, pz: cz, x: cx, y: cy, z: cz,
          vx: Math.cos(angle) * Math.cos(elev) * speed,
          vy: Math.sin(elev) * speed + 0.025,
          vz: Math.sin(angle) * Math.cos(elev) * speed,
          life: 0.7 + Math.random() * 0.5,
          hue: hue + (Math.random() - 0.5) * 0.1,
        });
        break;
      }
    }
  }
}

const _sparkCol = new THREE.Color();
function updateSparks(dt, au, dancers) {
  const GRAV = -0.006;
  for (let i = 0; i < SPARK_COUNT; i++) {
    const s = sparkState[i];
    if (s.life > 0) {
      s.px = s.x; s.py = s.y; s.pz = s.z;
      s.vx *= 0.973; s.vy += GRAV; s.vz *= 0.973;
      s.x += s.vx; s.y += s.vy; s.z += s.vz;
      s.life -= 0.012 + Math.random() * 0.007;
      if (s.y < -0.3) s.life = 0;
    }
    sparkPos[i*6+0] = s.px; sparkPos[i*6+1] = s.py; sparkPos[i*6+2] = s.pz;
    sparkPos[i*6+3] = s.x;  sparkPos[i*6+4] = s.y;  sparkPos[i*6+5] = s.z;
    const a = Math.max(0, s.life);
    _sparkCol.setHSL(s.hue, 1, 0.75);
    // tail dim, head bright
    sparkCol[i*6+0] = _sparkCol.r * a * 0.15; sparkCol[i*6+1] = _sparkCol.g * a * 0.15; sparkCol[i*6+2] = _sparkCol.b * a * 0.15;
    sparkCol[i*6+3] = _sparkCol.r * a;         sparkCol[i*6+4] = _sparkCol.g * a;         sparkCol[i*6+5] = _sparkCol.b * a;
  }
  sparkGeom.attributes.position.needsUpdate = true;
  sparkGeom.attributes.color.needsUpdate = true;

  // Beat burst from dancer
  if (au.beatDetected && dancers.length > 0) {
    const d = dancers[Math.floor(Math.random() * dancers.length)];
    const rp = palettes[currentPalette];
    spawnBurst(d.stageX, 1.0 + Math.random() * 0.6, d.stageZ, rp[Math.floor(Math.random() * rp.length)][0]);
  }
  // Ambient trickle
  if (Math.random() < 0.1 && dancers.length > 0) {
    const d = dancers[Math.floor(Math.random() * dancers.length)];
    for (let i = 0; i < SPARK_COUNT; i++) {
      if (sparkState[i].life <= 0) {
        const sx = d.stageX + (Math.random()-0.5)*1.2, sz = d.stageZ + (Math.random()-0.5)*1.2;
        const angle = Math.random() * Math.PI * 2, speed = 0.015 + Math.random() * 0.035;
        Object.assign(sparkState[i], {
          px: sx, py: 0.4+Math.random()*1.5, pz: sz,
          x: sx, y: 0.4+Math.random()*1.5, z: sz,
          vx: Math.cos(angle)*speed, vy: 0.025 + Math.random()*0.04, vz: Math.sin(angle)*speed,
          life: 0.5 + Math.random()*0.4, hue: Math.random(),
        });
        break;
      }
    }
  }
}

// ============================================================
// UI
// ============================================================
document.addEventListener('keydown', (e) => {
  if (e.key==='f'||e.key==='F') { if(!document.fullscreenElement)document.documentElement.requestFullscreen();else document.exitFullscreen(); }
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  if (composer) composer.setSize(window.innerWidth, window.innerHeight);
});


// ============================================================
// MAIN LOOP
// ============================================================
function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.05);
  const time = clock.getElapsedTime();

  audio.update(time);
  // Beat snap: ~25% chance per beat, pick a random active dancer
  if (audio.beatDetected && activeDancers.length > 0 && Math.random() > 0.75) {
    activeDancers[Math.floor(Math.random() * activeDancers.length)].triggerSnap();
  }
  dancerPool.forEach(d => d.update(dt, audio));

  // Collision avoidance (all pairs of active visible dancers)
  const visibleDancers = activeDancers.filter(d => d.scaleTarget > 0.5 && d.rootScene);
  for (let i = 0; i < visibleDancers.length; i++) {
    for (let j = i + 1; j < visibleDancers.length; j++) {
      const a = visibleDancers[i], b = visibleDancers[j];
      const dx = b.stageX - a.stageX, dz = b.stageZ - a.stageZ;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if (dist < 1.5 && dist > 0.001) {
        const push = (1.5 - dist) * 0.5, nx = dx/dist, nz = dz/dist;
        a.stageX -= nx*push; a.stageZ -= nz*push;
        b.stageX += nx*push; b.stageZ += nz*push;
        a.rootScene.position.x = a.stageX; a.rootScene.position.z = a.stageZ;
        b.rootScene.position.x = b.stageX; b.rootScene.position.z = b.stageZ;
      }
    }
  }

  // World switch timer
  worldSwitchTimer += dt;
  if (worldSwitchTimer > 15 || (audio.beatDetected && worldSwitchTimer > 8 && Math.random() > 0.97)) {
    worldSwitchTimer = 0;
    switchWorld(time);
    strobeFlash = 2.5; // big flash on world switch
  }

  worldGen.update(time);
  camSys.update(time, dt, audio, visibleDancers.length > 0 ? visibleDancers : activeDancers);
  updateLights(time, audio, visibleDancers.length > 0 ? visibleDancers : activeDancers);

  if (audio.beatDetected) overlay.triggerBeat(audio.bass);
  overlay.update(dt, worldGen.currentType);

  if (composer) composer.render(); else renderer.render(scene, camera);
}
animate();
    </script>
  </body>
</html>
